---
uuid: 72ad4890-cc34-11f0-b0dc-65842531b079
title: 2025-11-28-canvas设计-P0-元素编辑
category: 归档
mathjax: true
date: 2025-11-28 16:30:08
tags:
---

## 单元素和多元素拖拽移动机制

### 单元素拖拽机制

当用户选择单个元素并开始拖拽时，系统会执行以下步骤：

1. 在[handlePointerDown](/src/pages/canvas/Pixi_STM_modules/utils/interactionUtils.ts#L32-L149)函数中识别用户点击的是一个元素，并记录当前元素的初始状态到[dragInitialStates](/src/pages/canvas/Pixi_STM_modules/shared/types.ts#L25-L25)中。
2. 当用户开始移动鼠标时，系统进入拖拽模式，在[handleDraggingMove](/src/pages/canvas/Pixi_STM_modules/utils/dragUtils.ts#L33-L101)函数中计算元素的新位置。
3. 计算过程考虑了鼠标的当前位置与起始位置之间的偏移量，并将这个偏移量应用到元素的原始坐标上。
4. 系统实时更新元素的位置，并重新渲染画布。

具体实现中，系统会在[handleDraggingMove](/src/pages/canvas/Pixi_STM_modules/utils/dragUtils.ts#L33-L101)函数中进行以下操作：

```typescript
export function handleDraggingMove(
  state: ReturnType<typeof useStore.getState>,
  selectedIds: string[],
  startPos: { x: number; y: number },
  currentPos: { x: number; y: number },
  dragInitialStates: Record<string, Partial<CanvasElement>> | null,
  setDragInitialStates: (states: Record<string, Partial<CanvasElement>> | null) => void,
  updateState: any,
): {
  newStartPos: { x: number; y: number }
  dragDelta: { dx: number; dy: number }
  snapLines: any[]
} {
  // 如果是第一次拖拽且尚未记录初始状态，则记录初始状态
  let newDragInitialStates = dragInitialStates
  if (!dragInitialStates) {
    const initialDragMap: Record<string, any> = {}

    // 添加当前选中元素的所有后代元素（支持嵌套组）
    const allSelectedIds = [...selectedIds]
    selectedIds.forEach((id) => {
      const el = state.elements[id]
      if (el && el.type === 'group') {
        allSelectedIds.push(...getAllDescendantIds(id, state.elements))
      }
    })

    // 去重
    const uniqueIds = [...new Set(allSelectedIds)]

    uniqueIds.forEach((id) => {
      const el = state.elements[id]
      if (el) {
        // 记录 x, y (如果是直线/箭头，可能也需要记录 points)
        initialDragMap[id] = {
          x: el.x,
          y: el.y,
          points: el.points ? [...el.points.map((p) => [...p])] : undefined,
        }
      }
    })

    setDragInitialStates(initialDragMap)
    newDragInitialStates = initialDragMap

    // 保存到临时状态，确保在 onPointerUp 中可以访问
    if (updateState) {
      ;(updateState as any)._tempDragInitialStates = initialDragMap
    }

    // 开始拖拽时锁定撤销/重做管理器
    undoRedoManager.lock()
  }

  if (selectedIds.length > 0) {
    // 计算总位移 (Current - DragStart)
    const totalDx = currentPos.x - startPos.x
    const totalDy = currentPos.y - startPos.y

    let finalDx = totalDx
    let finalDy = totalDy
    let guidelines: any[] = []

    // 取第一个元素作为参考元素来计算辅助线
    const primaryElementId = selectedIds[0]
    // 确保有初始状态才继续
    if (!newDragInitialStates) {
      return { newStartPos: startPos, dragDelta: { dx: 0, dy: 0 }, snapLines: [] }
    }
    const primaryElementInitial = newDragInitialStates[primaryElementId]

    // 只有当选择单个元素时才计算辅助线，多元素选择时跳过以提升性能
    if (primaryElementInitial && selectedIds.length === 1) {
      // 创建带有新位置的临时元素用于计算辅助线
      const tempElement = {
        ...state.elements[primaryElementId],
        x: primaryElementInitial.x! + totalDx,
        y: primaryElementInitial.y! + totalDy,
      }

      // 计算辅助线和吸附位置
      const snapResult = calculateGuidelines(tempElement, state.elements, selectedIds)

      // 如果有吸附位置，则使用吸附后的位置

      const initialX = primaryElementInitial.x!
      const initialY = primaryElementInitial.y!

      if (snapResult.x !== undefined) finalDx = snapResult.x - initialX
      if (snapResult.y !== undefined) finalDy = snapResult.y - initialY
      guidelines = snapResult.guidelines
    }

    return {
      newStartPos: startPos,
      dragDelta: { dx: finalDx, dy: finalDy },
      snapLines: guidelines,
    }
  }

  return { newStartPos: startPos, dragDelta: { dx: 0, dy: 0 }, snapLines: [] }
}
```

在[StageInteractionHandler.onPointerMove](/src/pages/canvas/Pixi_STM_modules/interaction/Stage_InteractionHandler.ts#L106-L146)方法中，系统会：

```typescript
else if (this.state.mode === 'dragging') {
  // 使用新的 handleDraggingMove 函数，只计算坐标和增量，不更新 Store
  const dragResult = handleDraggingMove(
    state,
    state.selectedIds,
    this.state.startPos,
    currentPos,
    this.state.dragInitialStates,
    this.updateState.setDragInitialStates,
    this.updateState,
  )

  // 直接操作 Pixi 对象进行视觉反馈，不更新 Store
  const initialStates = this.state.dragInitialStates || (this.updateState as any)._tempDragInitialStates
  if (initialStates) {
    // 计算总位移 (Current - DragStart)
    let totalDx = currentPos.x - this.state.startPos.x
    let totalDy = currentPos.y - this.state.startPos.y

    // 获取精灵映射表
    const spriteMap = this.elementRendererSpriteMap()

    // 如果有吸附结果，使用修正后的位移
    if (dragResult.dragDelta.dx !== totalDx || dragResult.dragDelta.dy !== totalDy) {
      totalDx = dragResult.dragDelta.dx
      totalDy = dragResult.dragDelta.dy
    }

    // 核心优化：直接遍历选中的 Sprite 修改位置
    state.selectedIds.forEach((id) => {
      const sprite = spriteMap.get(id)
      const initData = initialStates[id]

      if (sprite && initData) {
        // 检查元素是否有旋转
        const element = state.elements[id]
        if (element && element.rotation !== undefined && element.rotation !== 0) {
          // 对于有旋转的元素，需要特殊处理位置
          // 旋转元素的pivot设置在中心，position也是基于中心的
          sprite.position.set(
            (initData.x || 0) + totalDx + (element.width || 0) / 2,
            (initData.y || 0) + totalDy + (element.height || 0) / 2,
          )
        } else {
          // 直接修改 Pixi 对象的 transform
          sprite.position.set((initData.x || 0) + totalDx, (initData.y || 0) + totalDy)
        }
      }
    })

    // 更新选择框位置
    const transformerGraphic = this.transformerRenderer.getGraphic()
    if (transformerGraphic) {
      transformerGraphic.position.set(totalDx, totalDy)
    }
  }

  // 更新辅助线显示
  if (dragResult.snapLines.length > 0) {
    if (typeof window !== 'undefined' && window.dispatchEvent) {
      window.dispatchEvent(new CustomEvent('drawGuidelines', { detail: dragResult.snapLines }))
    }
  } else {
    if (typeof window !== 'undefined' && window.dispatchEvent) {
      window.dispatchEvent(new CustomEvent('clearGuidelines'))
    }
  }
}
```

### 多元素拖拽机制

多元素拖拽的实现更复杂一些，因为它需要保持元素间的相对位置关系：

1. 当用户选择多个元素并开始拖拽时，系统会遍历所有选中的元素，并将它们的初始状态都记录在[dragInitialStates](/src/pages/canvas/Pixi_STM_modules/shared/types.ts#L25-L25)和[initialElementsMap](/src/pages/canvas/Pixi_STM_modules/shared/types.ts#L11-L11)中。
2. 与单元素拖拽类似，系统计算鼠标位置的偏移量。
3. 这个偏移量会被应用到每一个选中元素的原始坐标上，从而保持它们之间的相对位置不变。
4. 如果选中的元素中包含组(group)元素，系统还会递归地处理组内的子元素，确保整个组的完整性。

具体实现中，系统会收集所有选中元素及其后代元素（支持嵌套组）：

```typescript
// 添加当前选中元素的所有后代元素（支持嵌套组）
const allSelectedIds = [...selectedIds]
selectedIds.forEach((id) => {
  const el = state.elements[id]
  if (el && el.type === 'group') {
    allSelectedIds.push(...getAllDescendantIds(id, state.elements))
  }
})

// 去重
const uniqueIds = [...new Set(allSelectedIds)]
```

遍历所有这些元素，记录它们的初始状态（x、y 坐标和 points）：

```typescript
uniqueIds.forEach((id) => {
  const el = state.elements[id]
  if (el) {
    // 记录 x, y (如果是直线/箭头，可能也需要记录 points)
    initialDragMap[id] = {
      x: el.x,
      y: el.y,
      points: el.points ? [...el.points.map((p) => [...p])] : undefined,
    }
  }
})
```

在拖拽过程中，计算总位移并将其应用于每个元素：

```typescript
// 核心优化：直接遍历选中的 Sprite 修改位置
state.selectedIds.forEach((id) => {
  const sprite = spriteMap.get(id)
  const initData = initialStates[id]

  if (sprite && initData) {
    // 检查元素是否有旋转
    const element = state.elements[id]
    if (element && element.rotation !== undefined && element.rotation !== 0) {
      // 对于有旋转的元素，需要特殊处理位置
      // 旋转元素的pivot设置在中心，position也是基于中心的
      sprite.position.set(
        (initData.x || 0) + totalDx + (element.width || 0) / 2,
        (initData.y || 0) + totalDy + (element.height || 0) / 2,
      )
    } else {
      // 直接修改 Pixi 对象的 transform
      sprite.position.set((initData.x || 0) + totalDx, (initData.y || 0) + totalDy)
    }
  }
})
```

### 实现细节

在拖拽过程中，系统还实现了辅助线功能，帮助用户对齐元素。当元素接近其他元素时，系统会自动吸附并对齐，提升用户体验。

此外，系统使用了批量更新机制，将所有元素的位置更新合并为一次操作，然后通知渲染器进行重绘，这样可以显著提高性能，特别是在处理大量元素时。

在拖拽结束后，系统会在[StageInteractionHandler.onPointerUp](/src/pages/canvas/Pixi_STM_modules/interaction/Stage_InteractionHandler.ts#L310-L357)方法中：

```typescript
// [新增] 处理 Dragging (移动) 结束的命令记录
if (this.state.mode === 'dragging') {
  // 确保即使 dragInitialStates 是在移动过程中创建的也能正确执行命令
  const dragInitialStates = this.state.dragInitialStates || (this.updateState as any)._tempDragInitialStates

  // 拖拽结束时，将最终计算的位置写入 Store
  if (dragInitialStates) {
    // 获取最终的鼠标位置
    const currentPos = this.app.renderer.events.pointer.getLocalPosition(this.viewport)

    // 计算最终的位移（使用初始位置和最终位置计算，而不是累加）
    const totalDx = currentPos.x - this.state.startPos.x
    const totalDy = currentPos.y - this.state.startPos.y

    // 批量更新 Store (触发 Yjs transaction)
    const updates: Record<string, Partial<CanvasElement>> = {}

    state.selectedIds.forEach((id) => {
      const initData = dragInitialStates[id]
      //const element = state.elements[id]

      if (initData) {
        // 使用初始状态加上总位移来计算最终位置，避免累积误差
        updates[id] = {
          x: (initData.x || 0) + totalDx,
          y: (initData.y || 0) + totalDy,
        }
      }
    })

    // 批量更新元素
    Object.keys(updates).forEach((id) => {
      state.updateElement(id, updates[id])
    })

    // 执行命令 (Undo/Redo)
    import('../utils/commandUtils').then(({ executeMoveCommand }) => {
      executeMoveCommand(dragInitialStates, state)
    })
  }

  // 重置选择框位置
  const transformerGraphic = this.transformerRenderer.getGraphic()
  if (transformerGraphic) {
    transformerGraphic.position.set(0, 0)
  }
}
```

## 单元素和多元素缩放机制

缩放功能允许用户通过拖拽元素周围的控制手柄来改变元素的大小。系统支持对单个元素和多个元素同时进行缩放操作。

### 单元素缩放机制

对于单个元素的缩放，系统采用以下步骤：

1. 当用户点击并拖拽元素的控制手柄时，系统会确定缩放方向和比例。
2. 根据拖拽方向和距离，系统计算新的元素尺寸。
3. 更新元素的宽度、高度和位置属性。

具体实现中，系统使用[calculateScaling](/src/pages/canvas/Pixi_STM_modules/utils/scaleUtils.ts#L23-L240)函数来计算缩放结果：

```typescript
/**
 * 计算缩放操作的结果
 * @param initialElementsMap 初始元素状态映射
 * @param initialGroupBounds 初始组边界
 * @param selectedIds 选中的元素ID列表
 * @param handle 操作手柄类型
 * @param startPos 起始位置
 * @param currentPos 当前位置
 * @returns 缩放后各元素的新属性
 */
export function calculateScaling(
  initialElementsMap: Record<string, any>,
  initialGroupBounds: { x: number; y: number; width: number; height: number },
  selectedIds: string[],
  handle: string | null,
  startPos: { x: number; y: number },
  currentPos: { x: number; y: number },
) {
  // === 2. 确定"隐式组"的属性 ===

  // 2.1 确定组的旋转角度 (Group Angle)
  // - 单选或多选统一旋转：使用该统一角度
  // - 多选混合旋转：使用 0 度 (AABB)
  let groupAngle = 0

  // 检查统一旋转
  const firstRotation = initialElementsMap[selectedIds[0]]?.rotation || 0
  const isUniform = selectedIds.every((id) => Math.abs((initialElementsMap[id]?.rotation || 0) - firstRotation) < 0.001)
  if (isUniform) {
    groupAngle = firstRotation
  }

  // 2.2 确定组的旋转中心 (Pivot) - 使用初始包围盒的中心
  const groupCx = initialGroupBounds.x + initialGroupBounds.width / 2
  const groupCy = initialGroupBounds.y + initialGroupBounds.height / 2

  // 2.3 计算组在"去旋转"后的局部包围盒 (Local OBB)
  // 这一步是为了确定手柄操作的基准框
  let minLx = Infinity,
    maxLx = -Infinity,
    minLy = Infinity,
    maxLy = -Infinity

  Object.keys(initialElementsMap).forEach((id) => {
    const el = initialElementsMap[id]
    // 元素的四个角点
    const elCx = el.x + el.width / 2
    const elCy = el.y + el.height / 2
    const elHalfW = el.width / 2
    const elHalfH = el.height / 2
    const elRot = el.rotation || 0

    // 计算元素四个角点在世界坐标的位置
    // 然后将其旋转回组的局部坐标系
    const corners = [
      { x: -elHalfW, y: -elHalfH }, // TL
      { x: elHalfW, y: -elHalfH }, // TR
      { x: elHalfW, y: elHalfH }, // BR
      { x: -elHalfW, y: elHalfH }, // BL
    ].map((p) => {
      // 1. 元素自转转回世界坐标 (相对元素中心)
      const pWorldRel = rotatePoint(p.x, p.y, 0, 0, elRot)
      const pWorld = { x: elCx + pWorldRel.x, y: elCy + pWorldRel.y }
      // 2. 世界坐标转回组局部坐标 (相对组中心)
      return rotatePoint(pWorld.x, pWorld.y, groupCx, groupCy, -groupAngle)
    })

    corners.forEach((p) => {
      minLx = Math.min(minLx, p.x)
      maxLx = Math.max(maxLx, p.x)
      minLy = Math.min(minLy, p.y)
      maxLy = Math.max(maxLy, p.y)
    })
  })

  const groupInitLocalX = minLx
  const groupInitLocalY = minLy
  const groupInitLocalW = maxLx - minLx
  const groupInitLocalH = maxLy - minLy

  // === 3. 计算拖拽后的组局部包围盒 ===

  // 将鼠标位移转换到组的局部坐标系
  const startLocal = rotatePoint(startPos.x, startPos.y, groupCx, groupCy, -groupAngle)
  const currLocal = rotatePoint(currentPos.x, currentPos.y, groupCx, groupCy, -groupAngle)
  const dx = currLocal.x - startLocal.x
  const dy = currLocal.y - startLocal.y

  let newGroupLocalX = groupInitLocalX
  let newGroupLocalY = groupInitLocalY
  let newGroupLocalW = groupInitLocalW
  let newGroupLocalH = groupInitLocalH

  // 根据手柄调整尺寸 (固定对侧锚点)
  if (handle?.includes('l')) {
    newGroupLocalX += dx
    newGroupLocalW -= dx
  }
  if (handle?.includes('r')) {
    newGroupLocalW += dx
  }
  if (handle?.includes('t')) {
    newGroupLocalY += dy
    newGroupLocalH -= dy
  }
  if (handle?.includes('b')) {
    newGroupLocalH += dy
  }

  // 翻转处理 (Flip)
  let scaleXSign = 1
  let scaleYSign = 1
  if (newGroupLocalW < 0) {
    newGroupLocalW = Math.abs(newGroupLocalW)
    newGroupLocalX -= newGroupLocalW
    scaleXSign = -1
  }
  if (newGroupLocalH < 0) {
    newGroupLocalH = Math.abs(newGroupLocalH)
    newGroupLocalY -= newGroupLocalH
    scaleYSign = -1
  }

  // === 4. 对每个子元素进行矩阵变换模拟 ===
  const scaledElements: Record<string, Partial<CanvasElement>> = {}

  Object.keys(initialElementsMap).forEach((id) => {
    const initEl = initialElementsMap[id]
    if (!initEl) return

    // 4.1 获取元素初始的关键点 (中心 + 尺寸向量)
    // 为了精确模拟矩阵变换，我们追踪元素的三个关键点：左上(TL), 右上(TR), 左下(BL)
    // 通过变换后的这三个点，可以反解出新的 Width, Height, Rotation, XY
    const elCx = initEl.x + initEl.width / 2
    const elCy = initEl.y + initEl.height / 2
    const halfW = initEl.width / 2
    const halfH = initEl.height / 2
    const rot = initEl.rotation || 0

    // 原始局部向量 (相对于元素中心)
    const vTL = { x: -halfW, y: -halfH }
    const vTR = { x: halfW, y: -halfH }
    const vBL = { x: -halfW, y: halfH }

    // 定义变换函数：世界点 -> 组局部 -> 缩放 -> 组局部 -> 世界点
    const transformPoint = (localX: number, localY: number) => {
      // A. 元素局部 -> 世界
      const pWorldRel = rotatePoint(localX, localY, 0, 0, rot)
      const pWorld = { x: elCx + pWorldRel.x, y: elCy + pWorldRel.y }

      // B. 世界 -> 组局部 (Old)
      const pGroupLocal = rotatePoint(pWorld.x, pWorld.y, groupCx, groupCy, -groupAngle)

      // C. 计算在组内的相对比例 (0.0 - 1.0)
      const ratioX = groupInitLocalW === 0 ? 0 : (pGroupLocal.x - groupInitLocalX) / groupInitLocalW
      const ratioY = groupInitLocalH === 0 ? 0 : (pGroupLocal.y - groupInitLocalY) / groupInitLocalH

      // D. 映射到新组局部 (New)
      const pGroupLocalNewX = newGroupLocalX + ratioX * newGroupLocalW
      const pGroupLocalNewY = newGroupLocalY + ratioY * newGroupLocalH

      // E. 组局部 (New) -> 世界 (New)
      return rotatePoint(pGroupLocalNewX, pGroupLocalNewY, groupCx, groupCy, groupAngle)
    }

    // 4.2 变换关键点
    const newTL = transformPoint(vTL.x, vTL.y)
    const newTR = transformPoint(vTR.x, vTR.y)
    const newBL = transformPoint(vBL.x, vBL.y)

    // 4.3 反解属性
    // 新宽度 = TL 到 TR 的距离
    const newWidth = Math.sqrt(Math.pow(newTR.x - newTL.x, 2) + Math.pow(newTR.y - newTL.y, 2))
    // 新高度 = TL 到 BL 的距离
    const newHeight = Math.sqrt(Math.pow(newBL.x - newTL.x, 2) + Math.pow(newBL.y - newTL.y, 2))

    // 新中心 = (TL + TR + BL + BR)/2 => (TL + BR)/2
    // 利用矩形对角线性质：Mid(TL, BR) = Mid(TR, BL)
    // 计算 BR: newBR = newTR + (newBL - newTL) (向量加法)
    const vecTop = { x: newTR.x - newTL.x, y: newTR.y - newTL.y }
    const vecLeft = { x: newBL.x - newTL.x, y: newBL.y - newTL.y }

    // 中心点 = TL + 0.5 * vecTop + 0.5 * vecLeft
    const newCx = newTL.x + vecTop.x / 2 + vecLeft.x / 2
    const newCy = newTL.y + vecTop.y / 2 + vecLeft.y / 2

    // 新旋转 = TL 到 TR 的角度
    // 注意：这是世界坐标系下的角度
    const newRotation = Math.atan2(newTR.y - newTL.y, newTR.x - newTL.x)

    const finalX = newCx - newWidth / 2
    const finalY = newCy - newHeight / 2

    // 4.4 计算平均缩放比例 (用于字体/描边)
    const groupScaleX = groupInitLocalW === 0 ? 1 : newGroupLocalW / groupInitLocalW
    const groupScaleY = groupInitLocalH === 0 ? 1 : newGroupLocalH / groupInitLocalH
    const avgScale = (Math.abs(groupScaleX) + Math.abs(groupScaleY)) / 2

    const updatePayload: any = {
      x: finalX,
      y: finalY,
      width: newWidth,
      height: newHeight,
      rotation: newRotation,
    }

    // 点集处理 (Line/Arrow/Pencil)
    // 简单缩放处理：这对于路径类元素在非均匀缩放下是合理的近似（类似SVG viewBox scaling）
    if (initEl.points) {
      updatePayload.points = initEl.points.map((p: number[]) => {
        return [p[0] * groupScaleX * scaleXSign, p[1] * groupScaleY * scaleYSign]
      })
    }

    if (initEl.fontSize) updatePayload.fontSize = initEl.fontSize * avgScale
    if (initEl.strokeWidth) updatePayload.strokeWidth = initEl.strokeWidth * avgScale

    scaledElements[id] = updatePayload
  })

  // 清除之前的缓存超时
  if (cacheTimeout) {
    clearTimeout(cacheTimeout)
  }

  // 设置新的缓存超时（100ms后清除缓存）
  cacheTimeout = window.setTimeout(() => {
    scaleCache.clear()
  }, 100) as unknown as number

  return scaledElements
}
```

### 多元素缩放机制

多元素缩放更加复杂，因为需要保持元素间的相对位置和比例关系。系统使用以下方法处理多元素缩放：

1. 计算所有选中元素的包围盒作为整体缩放的参考
2. 根据手柄拖拽情况计算缩放比例
3. 将缩放比例应用到每个元素
4. 对于组元素，还需要递归处理组内子元素的缩放

在[StageInteractionHandler.onPointerMove](/src/pages/canvas/Pixi_STM_modules/interaction/Stage_InteractionHandler.ts#L106-L146)方法中，系统调用缩放计算函数并应用结果：

```typescript
else if (this.state.mode === 'resizing' && this.state.initialElementsMap && this.state.initialGroupBounds) {
  // === 【完美版】基于隐式组 + 矩阵变换模拟的缩放逻辑 ===
  const state = useStore.getState()
  const selectedIds = state.selectedIds
  const handle = this.state.activeHandle
  const initGroupBounds = this.state.initialGroupBounds

  // 1. 特殊处理：线段/箭头的端点拖拽 (逻辑保持不变，因为它们是基于点的)
  const singleId = selectedIds[0]
  const singleEl = this.state.initialElementsMap[singleId]
  if (
    selectedIds.length === 1 &&
    singleEl &&
    (singleEl.type === 'line' || singleEl.type === 'arrow') &&
    (handle === 'p0' || handle === 'p1')
  ) {
    const initX = singleEl.x ?? 0
    const initY = singleEl.y ?? 0
    const points = singleEl.points || [
      [0, 0],
      [0, 0],
    ]
    const p0Abs = { x: initX + points[0][0], y: initY + points[0][1] }
    const p1Abs = { x: initX + points[1][0], y: initY + points[1][1] }

    if (handle === 'p0') {
      p0Abs.x = currentPos.x
      p0Abs.y = currentPos.y
    } else {
      p1Abs.x = currentPos.x
      p1Abs.y = currentPos.y
    }
    const newX = Math.min(p0Abs.x, p1Abs.x)
    const newY = Math.min(p0Abs.y, p1Abs.y)
    const newW = Math.abs(p0Abs.x - p1Abs.x)
    const newH = Math.abs(p0Abs.y - p1Abs.y)
    const newPoints = [
      [p0Abs.x - newX, p0Abs.y - newY],
      [p1Abs.x - newX, p1Abs.y - newY],
    ]
    state.updateElement(singleId, { x: newX, y: newY, width: newW, height: newH, points: newPoints })
    return
  }

  // 使用分离的计算逻辑计算缩放结果
  const scaledElements = calculateScaling(
    this.state.initialElementsMap,
    this.state.initialGroupBounds,
    selectedIds,
    handle,
    this.state.startPos,
    currentPos,
  )

  // 批量更新所有元素，避免多次触发重新渲染
  state.batchUpdateElements(scaledElements)

  return
}
```

## 单元素和多元素旋转机制

旋转功能允许用户通过拖拽旋转手柄来改变元素的角度。系统同样支持对单个元素和多个元素同时进行旋转操作。

### 单元素旋转机制

单元素旋转是最基本的旋转操作，系统只需要围绕元素中心旋转元素即可：

1. 计算旋转中心（通常是元素的中心点）
2. 根据鼠标位置计算旋转角度
3. 更新元素的旋转属性

具体实现在[calculateRotation](/src/pages/canvas/Pixi_STM_modules/utils/rotationUtils.ts#L18-L88)函数中：

```typescript
/**
 * 计算旋转操作的结果
 * @param rotationInitialStates 旋转初始状态
 * @param rotationCenter 旋转中心点
 * @param startRotationAngle 起始旋转角度
 * @param currentPos 当前鼠标位置
 * @returns 旋转后各元素的新属性
 */
export function calculateRotation(
  rotationInitialStates: Record<string, any>,
  rotationCenter: { x: number; y: number },
  startRotationAngle: number,
  currentPos: { x: number; y: number },
) {
  const { x: cx, y: cy } = rotationCenter

  // 1. 计算当前鼠标角度
  const currentAngle = Math.atan2(currentPos.y - cy, currentPos.x - cx)

  // 2. 计算旋转增量（当前角度 - 起始角度）
  const deltaAngle = currentAngle - startRotationAngle

  // 3. 计算所有元素的新属性
  const rotatedElements: Record<string, Partial<CanvasElement>> = {}

  // 遍历所有选中元素并计算它们的旋转角度和位置
  Object.entries(rotationInitialStates).forEach(([id, initEl]) => {
    // 检查是否为组元素
    if (initEl.type === 'group') {
      // 对于组元素，计算新的自转角度
      const newRotation = initEl.rotation + deltaAngle

      // 计算新的位置 (公转)
      const newCenter = rotatePoint(initEl.cx, initEl.cy, cx, cy, deltaAngle)
      const newX = newCenter.x - initEl.width / 2
      const newY = newCenter.y - initEl.height / 2

      rotatedElements[id] = {
        x: newX,
        y: newY,
        rotation: newRotation,
      }

      // 注意：组内子元素的处理将在主逻辑中单独处理
    } else {
      // 普通元素的处理逻辑
      const newRotation = initEl.rotation + deltaAngle
      // 公转
      const newCenter = rotatePoint(initEl.cx, initEl.cy, cx, cy, deltaAngle)
      const newX = newCenter.x - initEl.width / 2
      const newY = newCenter.y - initEl.height / 2

      rotatedElements[id] = {
        x: newX,
        y: newY,
        rotation: newRotation,
      }
    }
  })

  // 清除之前的缓存超时
  if (cacheTimeout) {
    clearTimeout(cacheTimeout)
  }

  // 设置新的缓存超时（100ms后清除缓存）
  cacheTimeout = window.setTimeout(() => {
    rotationCache.clear()
  }, 100) as unknown as number

  return {
    rotatedElements,
    deltaAngle,
  }
}
```

### 多元素旋转机制

多元素旋转需要考虑所有元素作为一个整体进行旋转：

1. 计算所有选中元素的包围盒中心作为旋转中心
2. 计算相对于旋转中心的角度变化
3. 将角度变化应用到每个元素
4. 对于组元素，还需要处理组内子元素的旋转

在[StageInteractionHandler.onPointerMove](/src/pages/canvas/Pixi_STM_modules/interaction/Stage_InteractionHandler.ts#L106-L146)方法中，系统处理旋转操作：

```typescript
else if (
  this.state.mode === 'rotating' &&
  this.state.rotationInitialStates &&
  this.state.rotationCenter &&
  this.state.startRotationAngle !== null
) {
  // === [新增] 旋转逻辑 ===
  // 使用分离的计算逻辑计算旋转结果
  const { rotatedElements, deltaAngle } = calculateRotation(
    this.state.rotationInitialStates,
    this.state.rotationCenter,
    this.state.startRotationAngle,
    currentPos,
  )

  // 清除/绘制可视化辅助 (可选)
  this.resizeVisualizationGraphic.clear()
  // ... (绘制旋转中心)

  // 批量更新元素以提高性能
  const batchUpdates: Record<string, Partial<CanvasElement>> = {}

  // 收集所有需要更新的元素
  Object.entries(rotatedElements).forEach(([id, attrs]) => {
    batchUpdates[id] = attrs
  })

  // 处理组内子元素
  Object.entries(this.state.rotationInitialStates).forEach(([id, initEl]) => {
    if (initEl.type === 'group') {
      const childrenUpdates = calculateGroupChildrenRotation(
        this.state.rotationInitialStates!,
        id,
        deltaAngle,
        this.state.rotationCenter!,
      )

      Object.entries(childrenUpdates).forEach(([childId, attrs]) => {
        batchUpdates[childId] = attrs
      })
    }
  })

  // 一次性批量更新所有元素，避免多次触发重新渲染
  state.batchUpdateElements(batchUpdates)

  return
}
```

对于组内子元素的旋转，系统使用[calculateGroupChildrenRotation](/src/pages/canvas/Pixi_STM_modules/utils/rotationUtils.ts#L97-L130)函数进行处理：

```typescript
/**
 * 计算组内子元素的旋转结果
 * @param rotationInitialStates 旋转初始状态
 * @param groupId 组元素ID
 * @param deltaAngle 旋转角度增量
 * @param rotationCenter 旋转中心点
 * @returns 子元素的新属性
 */
export function calculateGroupChildrenRotation(
  rotationInitialStates: Record<string, any>,
  groupId: string,
  deltaAngle: number,
  rotationCenter: { x: number; y: number },
) {
  const { x: cx, y: cy } = rotationCenter
  const childrenUpdates: Record<string, Partial<CanvasElement>> = {}

  // 获取组元素
  const groupElement = rotationInitialStates[groupId] as any

  if (groupElement && groupElement.children) {
    groupElement.children.forEach((childId: string) => {
      const childInitEl = rotationInitialStates[childId]
      if (!childInitEl) return

      // 计算子元素新的位置
      const childNewCenter = rotatePoint(childInitEl.cx, childInitEl.cy, cx, cy, deltaAngle)
      const childNewX = childNewCenter.x - childInitEl.width / 2
      const childNewY = childNewCenter.y - childInitEl.height / 2

      childrenUpdates[childId] = {
        x: childNewX,
        y: childNewY,
        rotation: childInitEl.rotation + deltaAngle,
      }
    })
  }

  return childrenUpdates
}
```

无论是单元素还是多元素的操作，系统都采用了相似的设计思路：记录初始状态、计算变换参数、应用变换到元素、重新渲染。多元素操作的复杂性主要体现在需要处理多个元素的状态和保持它们之间的相对关系。
