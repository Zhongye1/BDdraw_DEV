# BDdraw_DEV 性能优化文档

## 概述

BDdraw_DEV 是一个基于 React、TypeScript 和 PixiJS 构建的 2D 画布应用。为了提升用户在处理大量元素时的交互体验，我们对拖拽、旋转和缩放操作进行了性能优化。

本文档详细介绍了这些优化措施的实现原理和效果。

## 优化目标

1. 提升大量元素同时操作时的流畅度
2. 减少 UI 卡顿和延迟
3. 优化内存使用
4. 保持代码的可维护性和可扩展性

## 核心优化策略

### 1. 计算与渲染分离

我们将计算逻辑（如旋转角度计算、缩放比例计算）与渲染逻辑（更新 PixiJS 对象）完全分离。

#### 实现方式：

- 创建独立的工具函数文件（如 `rotationUtils.ts`、`scaleUtils.ts`）
- 将复杂的数学计算集中在工具函数中
- 渲染层只负责更新视觉元素

#### 优势：

- 便于单元测试和调试
- 提高代码可读性和可维护性
- 允许独立优化计算和渲染部分

### 2. 批量更新机制

为了避免频繁的状态更新导致的性能问题，我们引入了批量更新机制。

#### 实现方式：

在 `canvasStore.ts` 中添加了 `batchUpdateElements` 方法：

```typescript
batchUpdateElements: (updates) => {
  // 使用 transact 保证原子性
  currentYDoc?.transact(() => {
    Object.entries(updates).forEach(([id, attrs]) => {
      const oldEl = currentYElements?.get(id)
      if (oldEl) {
        currentYElements?.set(id, { ...oldEl, ...attrs })
      }
    })
  })
}
```

#### 使用示例（旋转操作）：

```typescript
// 收集所有需要更新的元素
const batchUpdates: Record<string, Partial<CanvasElement>> = {}

// 收集旋转元素
Object.entries(rotatedElements).forEach(([id, attrs]) => {
  batchUpdates[id] = attrs
})

// 收集组内子元素
Object.entries(this.state.rotationInitialStates).forEach(([id, initEl]) => {
  if (initEl.type === 'group') {
    const childrenUpdates = calculateGroupChildrenRotation(...)
    Object.entries(childrenUpdates).forEach(([childId, attrs]) => {
      batchUpdates[childId] = attrs
    })
  }
})

// 一次性批量更新所有元素
state.batchUpdateElements(batchUpdates)
```

#### 优势：

- 减少状态更新次数
- 避免多次触发重新渲染
- 提高 Yjs 事务处理效率

### 3. 缓存机制

为了减少重复计算，我们引入了缓存机制。

#### 实现方式：

在工具函数中添加缓存清理逻辑：

```typescript
// 添加缓存机制
const rotationCache = new Map<string, { x: number; y: number; rotation: number }>()
let cacheTimeout: number | null = null

// 在计算函数中添加缓存清理逻辑
if (cacheTimeout) {
  clearTimeout(cacheTimeout)
}

// 设置新的缓存超时（100ms后清除缓存）
cacheTimeout = window.setTimeout(() => {
  rotationCache.clear()
}, 100) as unknown as number
```

#### 优势：

- 减少重复计算开销
- 提升操作流畅度
- 自动清理避免内存泄漏

### 4. 节流机制（预留）

为了进一步控制计算频率，我们实现了节流函数。

#### 实现方式：

```typescript
// 节流函数实现
const throttle = (func: (...args: any[]) => any, limit: number) => {
  let inThrottle: boolean
  return function(this: any, ...args: any[]) {
    if (!inThrottle) {
      func.apply(this, args)
      inThrottle = true
      setTimeout(() => (inThrottle = false), limit)
    }
  }
}

// 创建节流版本的计算函数
export const throttledCalculateRotation = throttle(calculateRotation, 16) // 约60fps
```

#### 优势：

- 控制计算频率
- 防止过度计算
- 可根据需要启用

## 具体操作优化

### 拖拽操作优化

#### 优化前问题：

- 每次鼠标移动都直接更新元素位置
- 大量元素时频繁触发状态更新和重新渲染

#### 优化后实现：

```typescript
// 直接操作 Pixi 对象进行视觉反馈，不更新 Store
state.selectedIds.forEach((id) => {
  const sprite = spriteMap.get(id)
  const initData = initialStates[id]

  if (sprite && initData) {
    // 直接修改 Pixi 对象的 transform
    sprite.position.set((initData.x || 0) + totalDx, (initData.y || 0) + totalDy)
  }
})

// 更新选择框位置
const transformerGraphic = this.transformerRenderer.getGraphic()
if (transformerGraphic) {
  transformerGraphic.position.set(totalDx, totalDy)
}
```

#### 优势：

- 视觉反馈即时，无延迟
- 避免频繁状态更新
- 拖拽结束时才批量更新状态

### 旋转操作优化

#### 优化前问题：

- 计算和渲染混合在一起
- 每个元素单独更新

#### 优化后实现：

1. 创建 `rotationUtils.ts` 独立工具文件
2. 实现 `calculateRotation` 和 `calculateGroupChildrenRotation` 函数
3. 使用批量更新机制

```typescript
// 使用分离的计算逻辑计算旋转结果
const { rotatedElements, deltaAngle } = calculateRotation(
  this.state.rotationInitialStates,
  this.state.rotationCenter,
  this.state.startRotationAngle,
  currentPos,
)

// 批量更新元素以提高性能
const batchUpdates: Record<string, Partial<CanvasElement>> = {}

// 收集所有需要更新的元素
Object.entries(rotatedElements).forEach(([id, attrs]) => {
  batchUpdates[id] = attrs
})

// 处理组内子元素
Object.entries(this.state.rotationInitialStates).forEach(([id, initEl]) => {
  if (initEl.type === 'group') {
    const childrenUpdates = calculateGroupChildrenRotation(...)
    Object.entries(childrenUpdates).forEach(([childId, attrs]) => {
      batchUpdates[childId] = attrs
    })
  }
})

// 一次性批量更新所有元素
state.batchUpdateElements(batchUpdates)
```

### 缩放操作优化

#### 优化前问题：

- 复杂的矩阵计算与渲染混合
- 每个元素单独更新

#### 优化后实现：

1. 创建 `scaleUtils.ts` 独立工具文件
2. 实现 `calculateScaling` 函数
3. 使用批量更新机制

```typescript
// 使用分离的计算逻辑计算缩放结果
const scaledElements = calculateScaling(
  this.state.initialElementsMap,
  this.state.initialGroupBounds,
  selectedIds,
  handle,
  this.state.startPos,
  currentPos
)

// 批量更新所有元素
state.batchUpdateElements(scaledElements)
```
