---
uuid: b594c210-c9a4-11f0-ad04-63fbb55bd414
title: 2025-11-25-关于canvas元素缩放-数学应用
category: 归档
mathjax: true
date: 2025-11-25 10:16:10
tags:
---

# Canvas 元素缩放的数学原理与实现

在图形编辑应用中，用户经常需要对一个或多个元素进行选择、移动、旋转和缩放等操作。Transformer 控制器负责渲染和管理这些操作所需的可视化控件。其实现背后有着复杂的数学原理，尤其是当处理多个元素的选择和变换时。

对于直线(line)和箭头(arrow)类型的元素，由于它们只由两个端点定义，因此采用特殊的处理方式。控制器会在两个端点处绘制圆形手柄，允许用户直接拖动端点来改变线条形状。这是最直观的编辑方式，因为线段的本质就是由两个端点决定的。

当涉及到常规元素如矩形(rect)、文本(text)或是多个元素组成的组(group)时，系统采用了一种更复杂的包围盒(Bounding Box)机制。在这种模式下，无论选择多少个元素，也不管它们各自的旋转状态如何，系统都需要计算出一个能够恰好包围所有选中元素的矩形框，并在这个框的周围布置控制手柄。

关键挑战在于如何处理不同旋转角度的多个元素。为了创建一个统一的控制框，系统首先判断是否所有选中元素都具有相同的角度。如果是这样（包括只选择了一个元素的情况），那么就采用这个统一的角度作为组的角度；否则，将组的角度设为 0，即不旋转。这个决策保证了在大多数情况下用户都能获得符合直觉的操作体验。

接下来是最核心的几何计算部分。为了得到准确的包围盒，系统不能简单地将各个元素的坐标范围进行合并，因为这没有考虑到旋转带来的影响。具体做法是：遍历每一个选中的元素，根据其自身的宽度和高度计算出四个角点的坐标，然后将这些点先按照元素自身的旋转角度进行变换，得到它们在世界坐标系中的实际位置。随后，再将这些世界坐标点反向旋转组的角度，把它们转换到一个假想的"组局部坐标系"中。在这个坐标系里计算出所有点的坐标范围，就得到了包围盒在未旋转状态下的宽度和高度。

有了尺寸信息之后，还需要确定包围盒的位置和朝向。包围盒的中心点等于其坐标范围的中心，但这个中心点目前还是处于组局部坐标系中的。为了让它回到世界坐标系，需要再次应用组的旋转角度进行变换。最终，通过中心点坐标、宽度、高度以及旋转角度这几个参数，就能完整地定义出包围盒的状态。

在渲染阶段，系统根据上述计算结果绘制包围盒的四条边。同时在每条边的中点和四个角点上绘制 8 个缩放手柄，以及在顶部中央上方绘制一个旋转手柄。这些手柄的位置同样需要经过旋转变换来确保与包围盒保持一致的方向。值得注意的是，为了提供良好的用户体验，手柄的大小会根据视口的缩放比例进行调整，使其始终保持合适的可视尺寸。

对于手柄的交互，每个手柄都配备了事件处理器。特别是缩放手柄，它们的鼠标光标会根据手柄类型和包围盒旋转角度动态调整，例如当鼠标悬停在角点手柄上时会显示斜向的调整光标。旋转手柄则采用了特殊的"抓取"光标，提示用户可以进行旋转操作。

在实际操作过程中，当用户开始拖动某个手柄时，系统会实时更新包围盒的尺寸或角度，并同步更新所选元素的位置和大小。这种同步是通过维护包围盒与元素之间的几何关系来实现的。比如当用户拖动右侧中间的手柄时，系统会计算新的宽度，并据此调整所有元素的尺寸和位置，使它们在组内的相对关系得以保持。

对于组元素还提供了额外的标识显示，通过在旋转手柄旁边添加文字标签来表明这是一个组合对象，这对于帮助用户理解和区分不同类型的选择状态非常有用。

这是一个非常好的问题。虽然代码中没有显式地写出 `[a, b, c, d, tx, ty]` 这种标准的 3x3 矩阵数组，但整个 `transformPoint` 函数的逻辑实际上就是一个完整的**仿射变换矩阵链（Chain of Affine Transformation Matrices）**的执行过程。

这种方法被称为**"基底变换与重映射（Basis Change and Remapping）"**。

下面我用通俗的几何语言配合数学公式，为你拆解这个"隐式矩阵"是如何应用和生效的。

---

## 追踪基底向量 (Tracking Basis Vectors)

在计算机图形学中，一个矩形（元素）由三个核心要素定义，这三个要素构成了它的**局部矩阵**：

1.  **原点 (Origin)**：通常是左上角 (TL) 或中心点。
2.  **X 轴向量 (Basis X)**：指向右上角 (TR) 的方向和长度。
3.  **Y 轴向量 (Basis Y)**：指向左下角 (BL) 的方向和长度。

**代码的魔法在于：** 我们不直接改 `width` 或 `height`，而是把这个矩形的三个关键点（TL, TR, BL）扔进一个"空间变形机"里跑一圈，看它们出来后变成了什么样子，然后**反推**出新的属性。

---

## 矩阵变换的四个步骤

代码中的 `transformPoint` 函数实际上执行了以下公式：

$$ P_{final} = (M_{group\_to\_world} \cdot S_{scale} \cdot M_{world\_to\_group}) \cdot P_{world} $$

让我们逐步拆解代码中对应的步骤：

### 步骤 1：构建坐标系（$M_{world\_to\_group}$）

我们把"隐式组"看作一个新的坐标系。

- **代码对应**：
  ```typescript
  // B. 世界 -> 组局部 (Old)
  const pGroupLocal = rotatePoint(pWorld.x, pWorld.y, groupCx, groupCy, -groupAngle)
  ```
  
  在 [Stage_InteractionHandler.ts](file:///e:/ADF-workbase/BDdraw_DEV/src/pages/canvas/Pixi_STM_modules/interaction/Stage_InteractionHandler.ts) 文件中，这个操作是变换流程的第一步，用于将世界坐标系中的点转换到组的局部坐标系中。

- **矩阵含义**：这是**逆变换矩阵**。它把世界坐标系下的点，搬运到"组"的局部空间里。在这个空间里，组是**正方向**的（旋转角为 0），方便我们做拉伸计算。

### 步骤 2：应用缩放/剪切（$S_{scale}$）

这是"手柄拖拽"真正发生作用的地方。

- **代码对应**：

  ```typescript
  // C. 计算在组内的相对比例 (0.0 - 1.0)
  const ratioX = (pGroupLocal.x - groupInitLocalX) / groupInitLocalW

  // D. 映射到新组局部 (New)
  const pGroupLocalNewX = newGroupLocalX + ratioX * newGroupLocalW
  ```

  这部分代码在 [Stage_InteractionHandler.ts](file:///e:/ADF-workbase/BDdraw_DEV/src/pages/canvas/Pixi_STM_modules/interaction/Stage_InteractionHandler.ts) 中实现，通过计算点在原始组局部坐标系中的相对位置，然后映射到新的组局部坐标系中。

- **矩阵含义**：这本质上是一个**缩放矩阵 (Scale Matrix)**。
  - 如果我们横向拉伸组，子元素在这个空间里的 X 坐标就会被拉长。
  - **关键点**：如果子元素在组内是斜着放的（比如组旋转 0 度，子元素旋转 45 度），那么在这一步，子元素的三个角点（TL, TR, BL）的相对位置会发生**非均匀**的变化。这实际上产生了一个**剪切 (Shear)** 效果。

### 步骤 3：还原回世界（$M_{group\_to\_world}$）

变形完成后，把点放回世界坐标系。

- **代码对应**：
  ```typescript
  // E. 组局部 (New) -> 世界 (New)
  return rotatePoint(pGroupLocalNewX, ..., groupCx, groupCy, groupAngle)
  ```
  
  这是 [Stage_InteractionHandler.ts](file:///e:/ADF-workbase/BDdraw_DEV/src/pages/canvas/Pixi_STM_modules/interaction/Stage_InteractionHandler.ts) 中变换流程的最后一步，将变换后的局部坐标点重新转换回世界坐标系。

- **矩阵含义**：这是**正向变换矩阵**。

---

## 为什么这一步能处理"剪切"？（矩阵分解/QR 分解）

这是最精彩的部分。

Canvas 和 DOM 元素通常不支持 `shear`（斜切）属性，只支持 `x, y, w, h, rotation`。
当一个旋转的物体被非均匀缩放时，它在数学上变成了一个平行四边形（Sheared Rectangle）。

代码是如何把这个"平行四边形"变回"矩形"属性的？

**代码对应（反解部分）：**

```typescript
// 4.3 反解属性
const newWidth = Math.sqrt(...)  // 计算新的边长
const newRotation = Math.atan2(newTR.y - newTL.y, newTR.x - newTL.x) // 计算新的角度
```

这部分实现在 [Stage_InteractionHandler.ts](file:///e:/ADF-workbase/BDdraw_DEV/src/pages/canvas/Pixi_STM_modules/interaction/Stage_InteractionHandler.ts) 的第 394-420 行左右。

**数学解释：**
我们通过追踪变形后的三个点 `newTL`, `newTR`, `newBL`，实际上是在做**极分解 (Polar Decomposition)** 的简化版：

1.  **旋转修正 (Rotation Adjustment)**：
    当我们将一个 45° 的正方形横向拉宽时，`newTL` 和 `newTR` 连线的角度不再是 45°，可能变成了 20°。
    _代码提取了这个新的角度 `newRotation`。_

2.  **尺寸修正 (Dimension Adjustment)**：
    新的 `newWidth` 是 `newTL` 到 `newTR` 的距离。

**结果**：
虽然数学上这应该是一个平行四边形，但因为 Canvas 只能画矩形，我们通过**旋转**来尽量拟合这个形状。

- 对于**组内的子元素**：这种拟合通常是完美的，因为它们是刚体变换的组合。
- 这种逻辑让子元素看起来像是"顺着"组的拉伸方向发生了自然的变形和旋转，而不是生硬地只改变宽高。

### 数据流视角

如果用矩阵公式写出整个流，就是：

$$
\begin{bmatrix} x' \\ y' \\ 1 \end{bmatrix} =
\underbrace{\begin{bmatrix} \cos\theta & -\sin\theta & cx \\ \sin\theta & \cos\theta & cy \\ 0 & 0 & 1 \end{bmatrix}}_{\text{Group Local to World}}
\times
\underbrace{\begin{bmatrix} S_x & 0 & 0 \\ 0 & S_y & 0 \\ 0 & 0 & 1 \end{bmatrix}}_{\text{Scaling Interaction}}
\times
\underbrace{\begin{bmatrix} \cos\theta & \sin\theta & -T_x \\ -\sin\theta & \cos\theta & -T_y \\ 0 & 0 & 1 \end{bmatrix}}_{\text{World to Group Local}}
\times
\begin{bmatrix} x_{elem} \\ y_{elem} \\ 1 \end{bmatrix}
$$

代码并没有显式存储这些 $3 \times 3$ 矩阵，而是通过：

1.  `rotatePoint` (旋转矩阵的应用)
2.  `ratio` 映射 (缩放矩阵的应用)
3.  向量距离和 `atan2` (矩阵分解/SVD)

完成了整套矩阵运算的模拟。这就是为什么这种方法被称为"完美法"，因为它遵循了仿射变换的几何法则。

---

# Canvas 交互系统重构文档：多选、旋转与缩放

## 1. 问题背景 (The Problem)

在重构之前，系统的画布交互（StageInteractionHandler）和渲染（TransformerRenderer）存在以下核心问题，导致用户体验不流畅，甚至产生逻辑错误：

### 1.1 坐标系错配 (Coordinate System Mismatch)

- **现象**：当用户选中一个已旋转 45° 的元素并尝试向"右"拖动手柄调整大小时，元素不仅变宽，还会发生意料之外的位移（漂移）。
- **原因**：旧逻辑基于 **AABB (轴对齐包围盒)** 计算。鼠标在屏幕水平方向的位移 $dx$ 被直接加到了元素的 `width` 上。但在旋转状态下，元素的"宽"是沿着 45° 轴向的，屏幕的 X 轴位移实际上同时改变了元素的局部宽和高。

### 1.2 多元素混合旋转的"剪切"难题 (The Shear Problem)

- **现象**：当同时选中一个旋转 0° 和一个旋转 45° 的元素，并进行横向拉伸时，45° 的元素会发生极其怪异的形变或位置错乱。
- **原因**：Canvas 基础图形通常只支持 `x, y, width, height, rotation`。当一个旋转的物体受到非均匀缩放（Non-uniform Scaling，例如只拉伸宽度）时，数学上它变成了一个**平行四边形**（发生了剪切/Shear）。旧逻辑无法处理这种几何变换，导致图形崩溃。

### 1.3 渲染与逻辑的"视觉错位" (Ghosting)

- **现象**：选中框（紫色框）和控制手柄与实际元素边缘不贴合，或者在旋转时，选中框的大小计算与手柄的实际控制范围不一致。
- **原因**：渲染器（Renderer）和交互控制器（Handler）使用了两套不同的包围盒计算算法。Renderer 简单地使用 `minX/maxX`，而 Handler 试图使用几何中心算法，两者在处理旋转投影时产生偏差。

---

## 2. 解决方案 (The Solution)

为了解决上述问题，我们引入了 **"隐式临时组 (Implicit Temporary Group)"** + **"矩阵变换模拟 (Matrix Simulation)"** 的完美方案。

### 2.1 引入"隐式组"与 OBB

无论用户选中了多少个元素，也无论它们旋转角度是否相同，在交互开始的一瞬间，我们都在数学上构建一个 **OBB (有向包围盒)**：

- **统一旋转**：如果所有选中元素旋转角度相同，OBB 的角度等于该角度。
- **混合旋转**：如果角度不同，OBB 的角度为 0°（退化为 AABB，但内部逻辑依然走矩阵变换）。

在代码中，这个逻辑实现在 [Stage_InteractionHandler.ts](file:///e:/ADF-workbase/BDdraw_DEV/src/pages/canvas/Pixi_STM_modules/interaction/Stage_InteractionHandler.ts) 和 [TF_controler_Renderer.ts](file:///e:/ADF-workbase/BDdraw_DEV/src/pages/canvas/Pixi_STM_modules/core/TF_controler_Renderer.ts) 中，通过检查所有选中元素的旋转角度是否一致来决定组的角度：

```typescript
// 检查统一旋转
let isUniform = false
const firstRotation = this.state.initialElementsMap[selectedIds[0]]?.rotation || 0
if (
  selectedIds.every((id) => Math.abs((this.state.initialElementsMap![id]?.rotation || 0) - firstRotation) < 0.001)
) {
  isUniform = true
  groupAngle = firstRotation
}
```

### 2.2 交互逻辑重写 (Stage_InteractionHandler)

不再直接修改 `width/height`，而是模拟图形学中的**矩阵变换链**：

1.  **构建基底**：确定"隐式组"的局部坐标系。
2.  **变换关键点**：对于每个子元素，追踪其三个关键点 —— **左上 (TL)**、**右上 (TR)**、**左下 (BL)**。
3.  **应用变换**：将这些点放入变换管道：`世界坐标 -> 组局部坐标 -> 缩放/拉伸 -> 组局部坐标 -> 世界坐标`。
4.  **反解属性 (Decomposition)**：变换完成后，三个关键点在世界坐标系中有了新位置。通过计算这三个点之间的距离和角度，**反向推导**出元素应有的新 `x, y, width, height, rotation`。

这个完整的流程在 [Stage_InteractionHandler.ts](file:///e:/ADF-workbase/BDdraw_DEV/src/pages/canvas/Pixi_STM_modules/interaction/Stage_InteractionHandler.ts) 的 `onPointerMove` 方法中实现，特别是在处理 `resizing` 模式时。

### 2.3 渲染逻辑对齐 (TransformerRenderer)

重写了 `renderTransformer` 方法，使其不再使用简单的 `el.x + el.width`。现在，渲染器会遍历所有选中元素的 4 个角点，将它们逆向旋转到"组"的坐标系中，找出精确的 `min/max` 边界。这确保了视觉上的选中框与逻辑上的控制框**像素级对齐**。

这个逻辑在 [TF_controler_Renderer.ts](file:///e:/ADF-workbase/BDdraw_DEV/src/pages/canvas/Pixi_STM_modules/core/TF_controler_Renderer.ts) 的 `renderTransformer` 方法中实现。

---

## 3. 数学原理深度解析 (Mathematical Principles)

核心算法基于线性代数中的 **基变换 (Change of Basis)** 和 **仿射变换 (Affine Transformation)**。

### 3.1 变换公式 (The "Sandwich" Transform)

任意一个点 $P_{world}$ 在经过用户拖拽缩放后的新位置 $P_{new}$，遵循以下矩阵连乘公式：

$$ P_{new} = M_{LocalToWorld} \cdot S_{scale} \cdot M_{WorldToLocal} \cdot P_{world} $$

在代码中，我们没有显式创建 $3 \times 3$ 矩阵，而是通过向量计算模拟了这一过程：

1.  **$M_{WorldToLocal}$ (进门)**：
    将点从世界坐标系映射到组的局部坐标系。这包含平移（减去中心点）和逆向旋转。
    $$ P_{local} = R(-\theta) \cdot (P_{world} - Center_{group}) $$

2.  **$S_{scale}$ (加工)**：
    在局部坐标系中，组是"正"的，可以直接应用缩放比例 $(S_x, S_y)$。代码中通过归一化坐标（Ratio）来实现这一点。
    $$ P'_{local}.x = P_{local}.x \times S_x $$
    $$ P'_{local}.y = P_{local}.y \times S_y $$

3.  **$M_{LocalToWorld}$ (出门)**：
    将变形后的点还原回世界坐标系。包含正向旋转和平移。
    $$ P_{final} = (R(\theta) \cdot P'_{local}) + Center_{group} $$

### 3.2 几何反解与极分解 (Geometry Decomposition)

这是解决"剪切问题"的关键。

当父级（组）进行非均匀缩放时，子元素在空间中实际上发生了**剪切**。由于我们不能直接设置 `shear` 属性，我们利用变换后的关键点进行近似拟合：

- **新位置 ($x, y$)**：由变换后的中心点决定。
  $$ Center_{new} = \frac{P'_{TL} + P'_{BR}}{2} $$
- **新宽度 ($width$)**：由变换后的 TL 和 TR 的距离决定（向量模长）。
  $$ Width_{new} = \| \vec{P'_{TR}} - \vec{P'_{TL}} \| $$
- **新旋转 ($rotation$)**：由变换后的 TL 指向 TR 的向量角度决定。
  $$ Rotation_{new} = \text{atan2}(y'_{TR} - y'_{TL}, x'_{TR} - x'_{TL}) $$

**效果**：当一个 45° 的正方形被横向拉伸，数学上它变成了平行四边形。通过上述反解，它会自动变成一个旋转角度约为 20°、宽度变大的长方形。这在视觉上完美模拟了矢量软件中的"Group Transform"行为，且没有破坏数据结构。

在 [Stage_InteractionHandler.ts](file:///e:/ADF-workbase/BDdraw_DEV/src/pages/canvas/Pixi_STM_modules/interaction/Stage_InteractionHandler.ts) 中，这部分逻辑通过以下代码实现：

```typescript
// 4.3 反解属性
// 新宽度 = TL 到 TR 的距离
const newWidth = Math.sqrt(Math.pow(newTR.x - newTL.x, 2) + Math.pow(newTR.y - newTL.y, 2))
// 新高度 = TL 到 BL 的距离
const newHeight = Math.sqrt(Math.pow(newBL.x - newTL.x, 2) + Math.pow(newBL.y - newTL.y, 2))

// 新旋转 = TL 到 TR 的角度
const newRotation = Math.atan2(newTR.y - newTL.y, newTR.x - newTL.x)
```

### 3.3 本地包围盒计算 (Renderer Logic)

为了修复手柄错位，渲染器现在计算的是 **Local OBB (Local Oriented Bounding Box)**。

对于集合中的每个元素 $E_i$，我们计算其 4 个角点 $C_{i,0...3}$，并将它们投影到组的轴上：
$$ C'_{i, k} = R(-\theta_{group}) \cdot (C_{i, k} - Center_{world}) $$

然后取所有投影点的极值：
$$ MinX = \min(C'_{all}.x), \quad MaxX = \max(C'_{all}.x) $$
$$ Width_{OBB} = MaxX - MinX $$

最终的选中框是这个 $Width_{OBB} \times Height_{OBB}$ 的矩形，再经过 $R(\theta_{group})$ 旋转回世界坐标。

这个计算过程在 [TF_controler_Renderer.ts](file:///e:/ADF-workbase/BDdraw_DEV/src/pages/canvas/Pixi_STM_modules/core/TF_controler_Renderer.ts) 中实现：

```typescript
// 计算元素四个角点在世界坐标的位置
const halfW = elW / 2
const halfH = elH / 2

const corners = [
  { x: -halfW, y: -halfH },
  { x: halfW, y: -halfH },
  { x: halfW, y: halfH },
  { x: -halfW, y: halfH },
].map((p) => {
  // 1. 元素局部 -> 世界 (考虑元素自身旋转)
  const pWorld = rotatePoint(elCx + p.x, elCy + p.y, elCx, elCy, elRot)
  // 2. 世界 -> 组局部 (逆向旋转 groupAngle，对齐到组轴)
  return rotatePoint(pWorld.x, pWorld.y, 0, 0, -groupAngle)
})

corners.forEach((p) => {
  minLx = Math.min(minLx, p.x)
  maxLx = Math.max(maxLx, p.x)
  minLy = Math.min(minLy, p.y)
  maxLy = Math.max(maxLy, p.y)
})
```

---

## 4. 总结

通过这次重构，我们实现了：

1.  **所见即所得**：交互手柄精确贴合元素边缘，无视觉错位。
2.  **数学正确性**：彻底解决了旋转物体缩放时的漂移问题。
3.  **高级功能支持**：完美支持多选混合旋转元素的非均匀缩放，实现了类似 Figma/Illustrator 的专业级交互体验。

代码实现在 [Stage_InteractionHandler.ts](file:///e:/ADF-workbase/BDdraw_DEV/src/pages/canvas/Pixi_STM_modules/interaction/Stage_InteractionHandler.ts) 和 [TF_controler_Renderer.ts](file:///e:/ADF-workbase/BDdraw_DEV/src/pages/canvas/Pixi_STM_modules/core/TF_controler_Renderer.ts) 中，通过精确的数学计算和矩阵变换模拟，确保了高质量的用户体验。